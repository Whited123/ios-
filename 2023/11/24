2023 / 11 / 24

오늘 배운 것:

1. 코드 테스트 
    1.1 숫자 짝꿍
        1.1.1 코드
            import Foundation

func solution(_ X:String, _ Y:String) -> String {
    var varY = Y
    var result = ""
    for i in X {
        if varY.contains(i) {
            result.append(i)
            if let jwoongBok = varY.firstIndex(of: i) {
                varY.remove(at: jwoongBok)
            }
        }
    }
    if result.isEmpty {
        return "-1"
    }
    var resultSet = result.sorted().reversed()
    if resultSet.first == "0" {
        return "0"
    }
    return String(resultSet)
}

        1.1.2 문제 리뷰
            입력값 문자열 X, Y가 주어질때 해당 문자열에서 겹치는 문자를 찾아 가장 큰 문자를 반환해야 한다.
            우선 X와 비교하고 수정하기위해 Y를 변경가능한 변수로 varY로 지정해주고, 결과값을 저장할 result변수를 만든다.
            그런다음 X에 반복문을 실행해 Y에 해당 문자가 있는지 체크하고 겹치는 문자를 result에 더해준 뒤 같은수가 중복되어서 더해지는걸 방지하기 위해 Y에서 발견한 중복문자는 제거해준다.
            그런다음 result가 비어있다면 겹치는 문자가 하나도 없는것이니 -1을 리턴한다.
            이후 resultSet변수를 만들어 문자열을 내림차순으로 정렬해주고, 만약 resultSet의 문자가 0으로 시작한다면 "0"을 리턴한다.
            그런다음 resultSet을 반환해주면 완성.
 
        1.1.3 개인적인 리뷰
            두 문자열을 비교하여 겹치는 부분을 제일 큰수로 리턴해주면 되는, 비교적 간단한 문제이다.
            어차피 X와 Y에 겹치는 문자는 어떤것을 기준으로 비교하든 결과가 같기때문에 X를 기준으로 문제풀이를 했고 Y내의 i를 추가로 찾아서 같은수가 두번이상 추가되지 않게 하는 계산식도 배웠다.
            그다음에 마지막으로 00과 같은 수를 배제해야 하기때문에 이리저리 머리를 굴렸는데, 처음에는 단순히 Set을 이용하여 결과를 도출해내거나 Set문자열을 만들어 문자를 하나하나 검사하면서 중복되는 0이 있는지 체크하는 계산식을 만들었으나
            0이외의 다른수도 중복이 제거 된다거나, 100같은 수가 10으로 줄어드는 경우의 수때문에 철회되었다.
            그런 와중에 문득 내림차순으로 정렬을 하면 자동으로 제일 큰수가 맨앞으로 오게 되는데, 이때 그게 0이라면 제일 큰수는 0이되는것이니 return "0"을 해주는것으로 해결하였다.
            중복처리에 대한 로직의 공부를 좀 더 해야할거같다. 저렇게 단순하게 처리되는 일이 많지않을것이고, 대형프로젝트에서는 중복처리에 대한 복잡할것이기 때문에 중요한 항목이라고 생각한다. 아직 갈길이 멀다.

    1.2 체육복
        1.2.1 코드
            import Foundation

func solution(_ n:Int, _ lost:[Int], _ reserve:[Int]) -> Int {
    var defaultBok = Array(repeating: 1, count: n)
    for i in lost {
        defaultBok[i - 1] -= 1
    }
    for i in reserve {
        defaultBok[i - 1] += 1
    }
    for (i, count) in defaultBok.enumerated() {
        if count == 0 {
            if i - 1 >= 0 && defaultBok[i - 1] == 2 {
                defaultBok[i - 1] -= 1
                defaultBok[i] += 1
            }
            if i + 1 < n && defaultBok[i + 1] == 2 {
                defaultBok[i + 1] -= 1
                defaultBok[i] += 1
            }
        }
    }
    return defaultBok.filter { $0 > 0 }.count
}

        1.2.2 문제 리뷰
            입력값 정수 n과 정수 배열 lost, reserve가 주어질때, n이 전체 학생수이고 lost가 체육복을 잃어버린 학생, reserve가 여벌의 체육복을 가지고 있는 학생일때 2개 이상의 체육복을 가지고있는 학생이 하나도 없는 학생에게 체육복을
            빌려줘서 체육복을 가지고 있는 학생의 수를 리턴해야한다.
            우선 defaultBok 변수를 생성하여 전체 학생들이 가지고 있는 체육복의 갯수를 한개로 세팅하고, 반복문을 각각 lost와 reserve에 실행하여 잃어버린 체육복과 여분 체육복을 계산한다.
            그리고 튜플반복문을 실행하여 학생들의 번호와 체육복의 갯수를 가져오고, 만약 체육복이 하나도 없을 경우 앞, 뒷자리의 학생 유무를 조사하고 그 학생의 체육복갯수가 2개이상이라면 +1 -1을 하여 체육복을 빌린다.
            그런다음 filter를 사용하여 체육복의 갯수가 0보다 많은 학생의 수를 리턴하면 완성.

        1.2.3 개인적인 리뷰
            체육복이 없는 학생들이 두개있는 학생들에게 빌려 최대한 많은 학생이 수업에 참가해야한다.
            처음에는 굉장히 간단한 문제라고 생각 했고 실제로도 간결한 코드로 완성했지만, 조건사항에서 여분의 체육복이 있는 학생도 lost에 들어갈수있고, 이렇게 되면 +-1이 되면서 대여를 해줄수없는 상태가 되기때문에 해당 로직을 구현하기 위해
            고민했던거 같다. 그래서 학생의 숫자에 직접 반복문을 실행하기보다 조사해야 하는 수인 체육복의 개수에 반복문을 시도 하였고 그러기 위해 디폴트값을 우선 설정해놓고, 도난과 여분을 조사하여 대여 전 학생들의 체육복 소지 여부상태를 만들수있었다.
            그런다음엔 두개 이상 가지고있는 앞뒤의 학생(index - 1)을 찾아 +-1을 해주면 되었는데, 여기서 맨 처음과 끝의 친구는 각각 앞뒤에 학생이 없기에 그걸 체크하는 조건문도 잊지 않고 넣어줬다.
            반복문이 끝나 대여가 완료된 배열이 나오면, filter함수를 사용해서 앞뒤에 학생이 없어 못빌린 0인 학생을 제외하고 빌린 학생의 수를 리턴해줬다. 늘 생각하는거지만 각각의 문제마다 수학에서 봤었던 개념들을 코드상에서 녹여내는 느낌이다.
            전체를 암기하지말고 함수와 로직을 통해서 이 함수가 어떤일을 하고 로직을 어떻게 짜야 작동하는지를 제대로 이해하고 넘어가자.












